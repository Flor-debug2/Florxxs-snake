<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Florrxxs — Candy Crush (Minimal)</title>
  <style>
    :root{
      --bg:#0b0b0b;
      --card:#111111;
      --accent:#ff3b3b; /* red */
      --muted:#bdbdbd;
      --glass: rgba(255,255,255,0.03);
      --gap:8px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:var(--muted);background:linear-gradient(180deg,#050505 0%, #0d0d0d 100%)}
    .wrap{max-width:980px;margin:28px auto;padding:24px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(0,0,0,0.6);display:grid;grid-template-columns:320px 1fr;gap:20px}

    /* left panel */
    .panel{background:var(--card);padding:18px;border-radius:12px;color:#eee}
    h1{margin:0 0 6px;font-size:20px;color:var(--accent)}
    p.lead{margin:0 0 14px;color:var(--muted);font-size:13px}

    .controls{display:flex;gap:8px;margin-bottom:12px}
    button{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));color:var(--muted);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:10px;cursor:pointer}
    button.primary{background:linear-gradient(180deg,var(--accent),#b30000);color:white;border:none}

    .scorebox{display:flex;gap:10px;align-items:center;margin-bottom:10px}
    .score{font-size:20px;color:#fff}
    .meta{font-size:12px;color:var(--muted)}

    /* board */
    .board-wrap{display:flex;align-items:center;justify-content:center}
    #board{width:400px;height:400px;background:var(--glass);border-radius:12px;padding:12px;display:grid;grid-template-columns:repeat(8,1fr);grid-gap:var(--gap);position:relative}
    .cell{background:transparent;border-radius:8px;display:flex;align-items:center;justify-content:center;transition:transform 200ms ease}
    .candy{width:100%;height:100%;display:flex;align-items:center;justify-content:center;border-radius:8px;cursor:pointer;user-select:none;transition:transform 150ms ease, filter 200ms}
    .candy.pulse{transform:scale(1.06)}

    /* candy types */
    .type-0{background:linear-gradient(180deg,#ffb3b3,#ff3b3b);box-shadow:0 4px 10px rgba(255,59,59,0.25)}
    .type-1{background:linear-gradient(180deg,#ffd8a8,#ff9f3b);box-shadow:0 4px 10px rgba(255,159,59,0.2)}
    .type-2{background:linear-gradient(180deg,#9dffb8,#3bff6b);box-shadow:0 4px 10px rgba(59,255,107,0.15)}
    .type-3{background:linear-gradient(180deg,#a8d1ff,#3b9bff);box-shadow:0 4px 10px rgba(59,155,255,0.1)}
    .type-4{background:linear-gradient(180deg,#e8b8ff,#c13bff);box-shadow:0 4px 10px rgba(193,59,255,0.12)}
    .type-5{background:linear-gradient(180deg,#fff4a8,#fff23b);box-shadow:0 4px 10px rgba(255,242,59,0.12)}

    /* nice touches */
    .cell.removing .candy{filter:grayscale(60%) brightness(.8);opacity:0;transform:scale(.2) rotate(20deg)}
    .message{padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}

    footer{grid-column:1/-1;margin-top:10px;color:#777;font-size:12px;text-align:center}

    @media (max-width:780px){.wrap{grid-template-columns:1fr;max-width:92vw}.board-wrap{justify-content:flex-start}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>florxxs — Match 3</h1>
      <p class="lead">A minimal, single-file Candy Crush style demo. Swap adjacent candies to make matches of 3 or more. Built for you in HTML/CSS/JS.</p>

      <div class="scorebox">
        <div>
          <div class="meta">Score</div>
          <div id="score" class="score">0</div>
        </div>
        <div style="margin-left:auto;text-align:right">
          <div class="meta">Moves</div>
          <div id="moves" class="score">0</div>
        </div>
      </div>

      <div class="controls">
        <button id="newBtn" class="primary">New Game</button>
        <button id="hintBtn">Hint</button>
        <button id="shuffleBtn">Shuffle</button>
      </div>

      <div class="message">
        <strong>How to play:</strong> Click a candy and then click an adjacent candy to swap. Make matches of 3+ to score. You can also drag to swap.
      </div>

      <div style="height:14px"></div>
      <div style="font-size:12px;color:var(--muted)">Tip: I used a compact 8×8 board and six candy types. Want special candies, levels, or mobile controls? Tell me and I’ll extend it.</div>
    </div>

    <div class="board-wrap panel" style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
      <div id="board" aria-label="game board"></div>
    </div>

    <footer>Made for Florxxs • Open this file in your browser to play</footer>
  </div>

  <script>
    /* Minimal Match-3 engine */
    const cols = 8, rows = 8, types = 6
    const boardEl = document.getElementById('board')
    const scoreEl = document.getElementById('score')
    const movesEl = document.getElementById('moves')
    const newBtn = document.getElementById('newBtn')
    const hintBtn = document.getElementById('hintBtn')
    const shuffleBtn = document.getElementById('shuffleBtn')

    let grid = [] // 2D array of ints or null
    let cells = [] // DOM cells
    let selected = null
    let score = 0, moves = 0
    let animating = false

    function init(){
      grid = Array(rows).fill(0).map(()=>Array(cols).fill(0))
      boardEl.innerHTML = ''
      cells = []
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const idx = r*cols+c
          const cell = document.createElement('div')
          cell.className = 'cell'
          cell.style.width = `calc((100% - (${cols-1}*var(--gap))) / ${cols})`
          cell.style.height = cell.style.width

          const candy = document.createElement('div')
          candy.className = 'candy'
          candy.dataset.r = r; candy.dataset.c = c
          candy.draggable = true

          cell.appendChild(candy)
          boardEl.appendChild(cell)
          cells.push(cell)

          candy.addEventListener('click', onCandyClick)
          candy.addEventListener('dragstart', onDragStart)
          candy.addEventListener('dragover', e=>e.preventDefault())
          candy.addEventListener('drop', onDrop)
        }
      }
      fillBoard(true)
      score = 0; moves = 0; updateHUD()
    }

    function randomType(){ return Math.floor(Math.random()*types) }

    function fillBoard(initial=false){
      // Fill with types while avoiding starting matches
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          let t
          do{ t = randomType() } while((r>=2 && grid[r-1][c]===t && grid[r-2][c]===t) || (c>=2 && grid[r][c-1]===t && grid[r][c-2]===t))
          grid[r][c] = t
          setCandyAt(r,c,t, initial)
        }
      }
    }

    function setCandyAt(r,c,t,initial=false){
      const idx = r*cols+c
      const candy = cells[idx].firstChild
      candy.className = 'candy type-' + t
      candy.textContent = ''
      candy.style.transform = initial ? 'scale(1)' : 'scale(1)'
      candy.dataset.type = t
    }

    function onCandyClick(e){
      if(animating) return
      const el = e.currentTarget
      const r = +el.dataset.r, c = +el.dataset.c
      if(!selected){ select(el); return }
      const sr = +selected.dataset.r, sc = +selected.dataset.c
      if((Math.abs(sr-r)+Math.abs(sc-c))===1){
        swapAndResolve(sr,sc,r,c)
      } else {
        select(el)
      }
    }

    function select(el){
      if(selected) selected.classList.remove('pulse')
      selected = el
      if(selected) selected.classList.add('pulse')
    }

    function onDragStart(e){
      if(animating) return e.preventDefault()
      e.dataTransfer.setData('text/plain', JSON.stringify({r:+e.currentTarget.dataset.r,c:+e.currentTarget.dataset.c}))
    }
    function onDrop(e){
      if(animating) return
      const src = JSON.parse(e.dataTransfer.getData('text/plain'))
      const dst = {r:+e.currentTarget.dataset.r,c:+e.currentTarget.dataset.c}
      if(Math.abs(src.r-dst.r)+Math.abs(src.c-dst.c)===1){ swapAndResolve(src.r,src.c,dst.r,dst.c) }
    }

    function swapAndResolve(r1,c1,r2,c2){
      animating = true
      moves++;
      updateHUD()
      swapGrid(r1,c1,r2,c2)
      animateSwap(r1,c1,r2,c2).then(()=>{
        const matches = findMatches()
        if(matches.length===0){
          // swap back
          swapGrid(r1,c1,r2,c2)
          animateSwap(r1,c1,r2,c2).then(()=>{ animating=false })
        } else {
          // resolve chain
          resolveAll().then(()=>{ animating=false })
        }
      })
    }

    function swapGrid(r1,c1,r2,c2){
      const tmp = grid[r1][c1]; grid[r1][c1]=grid[r2][c2]; grid[r2][c2]=tmp
      setCandyAt(r1,c1,grid[r1][c1]); setCandyAt(r2,c2,grid[r2][c2])
    }

    function animateSwap(r1,c1,r2,c2){
      return new Promise(res=>{
        const a = cells[r1*cols+c1].firstChild
        const b = cells[r2*cols+c2].firstChild
        const rectA = a.getBoundingClientRect(); const rectB = b.getBoundingClientRect()
        const dx = rectB.left - rectA.left; const dy = rectB.top - rectA.top
        a.style.transition = 'transform 220ms ease'; b.style.transition = 'transform 220ms ease'
        a.style.transform = `translate(${dx}px, ${dy}px)`
        b.style.transform = `translate(${-dx}px, ${-dy}px)`
        setTimeout(()=>{
          a.style.transition=''; b.style.transition=''
          a.style.transform=''; b.style.transform=''
          res()
        },240)
      })
    }

    function findMatches(){
      const matches = []
      // horizontal
      for(let r=0;r<rows;r++){
        let run=[{r,c:0}]
        for(let c=1;c<cols;c++){
          if(grid[r][c]===grid[r][c-1]) run.push({r,c})
          else{ if(run.length>=3) matches.push([...run]); run=[{r,c}] }
        }
        if(run.length>=3) matches.push([...run])
      }
      // vertical
      for(let c=0;c<cols;c++){
        let run=[{r:0,c}]
        for(let r=1;r<rows;r++){
          if(grid[r][c]===grid[r-1][c]) run.push({r,c})
          else{ if(run.length>=3) matches.push([...run]); run=[{r,c}] }
        }
        if(run.length>=3) matches.push([...run])
      }
      return matches
    }

    async function resolveAll(){
      while(true){
        const matches = findMatches()
        if(matches.length===0) break
        // flatten unique cells
        const removeSet = new Set()
        matches.forEach(run=> run.forEach(cell=> removeSet.add(cell.r*cols+cell.c)))
        const toRemove = Array.from(removeSet)
        // animate removal
        toRemove.forEach(idx=> cells[idx].classList.add('removing'))
        await wait(260)
        score += toRemove.length * 10
        updateHUD()
        // set to null
        toRemove.forEach(idx=>{
          const r = Math.floor(idx/cols), c = idx%cols
          grid[r][c] = null
          const candy = cells[idx].firstChild
          candy.className = 'candy'
          candy.dataset.type = ''
        })
        await wait(50)
        collapseColumns()
        await wait(180)
        refill()
        await wait(200)
      }
    }

    function collapseColumns(){
      for(let c=0;c<cols;c++){
        let write = rows-1
        for(let r=rows-1;r>=0;r--){
          if(grid[r][c]!==null && grid[r][c]!==undefined){ grid[write][c]=grid[r][c]; write-- }
        }
        for(let r=write;r>=0;r--) grid[r][c]=null
      }
      // update DOM to reflect moved ones
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const idx=r*cols+c
        const candy = cells[idx].firstChild
        if(grid[r][c]===null){ candy.className='candy'; candy.dataset.type=''; }
        else{ candy.className='candy type-'+grid[r][c]; candy.dataset.type=grid[r][c] }
      }
    }

    function refill(){
      for(let c=0;c<cols;c++){
        for(let r=0;r<rows;r++){
          if(grid[r][c]===null || grid[r][c]===undefined){
            grid[r][c] = randomType()
            setCandyAt(r,c,grid[r][c])
            // tiny pop animation
            const el = cells[r*cols+c].firstChild
            el.style.transform = 'scale(.2)'
            setTimeout(()=> el.style.transform='scale(1)',50)
          }
        }
      }
    }

    function wait(ms){ return new Promise(res=>setTimeout(res,ms)) }

    function updateHUD(){ scoreEl.textContent = score; movesEl.textContent = moves }

    // small hint finder: find any legal swap that yields a match
    function findHint(){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const dirs = [[1,0],[-1,0],[0,1],[0,-1]]
          for(const d of dirs){
            const nr=r+d[0], nc=c+d[1]
            if(nr<0||nr>=rows||nc<0||nc>=cols) continue
            swapGrid(r,c,nr,nc)
            const m = findMatches()
            swapGrid(r,c,nr,nc)
            if(m.length>0) return [{r,c},{r:nr,c:nc}]
          }
        }
      }
      return null
    }

    hintBtn.addEventListener('click', ()=>{
      const h = findHint()
      if(!h) { alert('No obvious matches — try Shuffle') ; return }
      const idx = h[0].r*cols+h[0].c
      const idx2 = h[1].r*cols+h[1].c
      cells[idx].firstChild.classList.add('pulse')
      setTimeout(()=>cells[idx].firstChild.classList.remove('pulse'),700)
      cells[idx2].firstChild.classList.add('pulse')
      setTimeout(()=>cells[idx2].firstChild.classList.remove('pulse'),700)
    })

    shuffleBtn.addEventListener('click', ()=>{
      // Fisher-Yates shuffle of all tiles
      const arr = []
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) arr.push(grid[r][c])
      for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] }
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){ grid[r][c]=arr[r*cols+c]; setCandyAt(r,c,grid[r][c]) }
    })

    newBtn.addEventListener('click', init)

    // start
    init()

    // expose for debugging
    window._grid = grid
  </script>
</body>
</html>
